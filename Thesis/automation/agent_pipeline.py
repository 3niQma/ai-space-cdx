#!/usr/bin/env python3
"""
Utility to orchestrate the multi-agent literature-review workflow offline.

The pipeline reads agent definitions from automation/config/agents.json,
creates placeholder artifacts for each agent output (unless --dry-run is set),
and logs execution metadata under automation/logs/.
"""

from __future__ import annotations

import argparse
import datetime as dt
import json
import sys
from pathlib import Path
from typing import Dict, List

ROOT = Path(__file__).resolve().parent.parent
CONFIG_PATH = ROOT / "automation" / "config" / "agents.json"
LOG_DIR = ROOT / "automation" / "logs"
LOG_FILE = LOG_DIR / "agent_pipeline.jsonl"

PLACEHOLDER_CONTENT: Dict[str, str] = {
    "data/prisma/search_log.csv": "source,query,filters,export_date,hit_count\n",
    "data/prisma/screening_log.csv": (
        "paper_id,title,abstract_decision,fulltext_decision,reason,notes\n"
    ),
    "data/processed/study_catalog.csv": (
        "paper_id,title,year,manufacturing_domain,rl_method,baseline,kpis,notes\n"
    ),
    "data/processed/synthesis_notes.md": (
        "# Synthesis Notes\n\nReplace this file with narrative findings generated by the "
        "synthesis agent.\n"
    ),
    "data/processed/qa_report.md": (
        "# QA Report\n\nDocument coverage checks, PRISMA compliance, and outstanding actions.\n"
    ),
}


def read_config(path: Path) -> Dict[str, List[dict]]:
    with path.open("r", encoding="utf-8") as handle:
        return json.load(handle)


def ensure_placeholder(output_path: Path, dry_run: bool) -> str:
    try:
        rel_path = output_path.relative_to(ROOT)
    except ValueError:
        rel_path = output_path
    rel_str = rel_path.as_posix() if isinstance(rel_path, Path) else str(rel_path)
    if not output_path.exists() and not dry_run:
        output_path.parent.mkdir(parents=True, exist_ok=True)
        template = PLACEHOLDER_CONTENT.get(rel_str.replace("\\", "/"))
        if template is not None:
            output_path.write_text(template, encoding="utf-8")
            return f"created placeholder ({rel_str})"
        output_path.touch()
        return f"touched empty file ({rel_str})"
    if output_path.exists():
        return f"exists ({rel_str})"
    return f"would create ({rel_str})"


def run_pipeline(config_path: Path, dry_run: bool) -> List[dict]:
    config = read_config(config_path)
    agents = config.get("agents", [])
    timestamp = dt.datetime.utcnow().isoformat() + "Z"
    LOG_DIR.mkdir(parents=True, exist_ok=True)

    run_records: List[dict] = []

    for agent in agents:
        record = {
            "timestamp": timestamp,
            "agent": agent["name"],
            "description": agent.get("description", ""),
            "actions": [],
        }
        for output in agent.get("outputs", []):
            action = ensure_placeholder(ROOT / output, dry_run=dry_run)
            record["actions"].append({"output": output, "status": action})
        run_records.append(record)

    if not dry_run:
        with LOG_FILE.open("a", encoding="utf-8") as log_handle:
            for record in run_records:
                log_handle.write(json.dumps(record) + "\n")

    return run_records


def format_summary(records: List[dict]) -> str:
    lines = []
    for record in records:
        lines.append(f"[{record['agent']}] {record['description']}")
        for action in record["actions"]:
            lines.append(f"  - {action['output']}: {action['status']}")
    return "\n".join(lines)


def parse_args(argv: List[str]) -> argparse.Namespace:
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument(
        "--config",
        type=Path,
        default=CONFIG_PATH,
        help="Path to the agent configuration JSON file.",
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Simulate the pipeline without creating files or logs.",
    )
    return parser.parse_args(argv)


def main(argv: List[str]) -> int:
    args = parse_args(argv)
    records = run_pipeline(args.config, args.dry_run)
    print(format_summary(records))
    if args.dry_run:
        print("\nDry-run mode: no files or logs were created.", file=sys.stderr)
    return 0


if __name__ == "__main__":
    raise SystemExit(main(sys.argv[1:]))
